/*! \file ODIM_struct.h
\brief General definitions and structures for IRIStoODIM software.

These definitions and structures are used both <I>IRIS_decoder.c</I> and 
<I>ODIM_encoder.c</I>. Quantity names are according to ODIM information model
(OPERA Working Document WD_2008_03) and the structure member variables are the same as
in the information model and documented there. 
Only those members used internally to relay information between <B>IRIS_decoder</B> and 
<B>ODIM_encoder</B> are explicitely documented here. However, the QuantCfg members 
are given here as an example. 

Data is organized so that the root level (e.g. /what) contains common attributes
for all data. Dataset attributes (e.g. /dataset1/what) are common for all data types of a scan,
and quantity attributes (e.g. /dataset2/data3/what) defines the characteristics of one data type, 
e.g. reflectivity, doppler velocity etc. These all are combined to MetaData structure having
fixed size: Maximum number of datasets (scans) in one file is 50 and maximum number of datatypes 
in a dataset is 64.

The intermediate data/metadata file written by IRIS_decoder and read by
ODIM_encoder is generated by dumping the MetaData structure to disk 
immediately followed by data dump.
*/

/*!\def OQ_QUANTS_TOTAL
/\brief Codes reserved for radar data quantities 
*/
# define OQ_QUANTS_TOTAL 300
/*!\def MAX_QUANTS
\brief maximum amount of IRIS quantities 
*/ 
# define MAX_QUANTS 128
/*!\def MAX_SCANS
\brief maximum amount of scans in one file 
*/ 
# define MAX_SCANS 50
/*!\def MAX_AZIMS
\brief maximum amount of azimuths in one scan 
*/ 
# define MAX_AZIMS 3600

/*!\def TWOB
\brief Codes incremented by this are reserved for 2-byte data 
*/
# define TWOB 200 
# define OQ_DEF      1 /* Default, not used */    
# define OQ_DEF2     (OQ_DEF + TWOB) /* Default 2-byte quantity */

/*!\def OQ_TH
\brief Total reflectivity, 1-byte resolution 
*/
# define OQ_TH       2 

/*!\def OQ_TH2
\brief Total reflectivity 2-byte. All following OQ_ definitions obey this scheme.  
*/
# define OQ_TH2      (OQ_TH + TWOB) 

# define OQ_DBZH     3
# define OQ_DBZH2    (OQ_DBZH + TWOB)

# define OQ_VRADH    4
# define OQ_VRADH2   (OQ_VRADH + TWOB)

# define OQ_WRADH    5
# define OQ_WRADH2   (OQ_WRADH + TWOB)

# define OQ_SQIH     6
# define OQ_SQIH2     (OQ_SQIH + TWOB)

# define OQ_ZDR      7
# define OQ_ZDR2     (OQ_ZDR + TWOB)

# define OQ_LDR      8
# define OQ_LDR2     (OQ_LDR + TWOB)

# define OQ_LDRV     9
# define OQ_LDRV2    (OQ_LDRV + TWOB)

# define OQ_RHOHV    10
# define OQ_RHOHV2   (OQ_RHOHV + TWOB)

# define OQ_PHIDP    11
# define OQ_PHIDP2   (OQ_PHIDP + TWOB)

# define OQ_KDP      12
# define OQ_KDP2     (OQ_KDP + TWOB)

# define OQ_HCLASS   13
# define OQ_HCLASS2  (OQ_HCLASS + TWOB)

# define OQ_VRADDH   14
# define OQ_VRADDH2  (OQ_VRADDH + TWOB)

# define OQ_DBZHC    15
# define OQ_DBZHC2   (OQ_DBZHC + TWOB)

# define OQ_ZDRC     16
# define OQ_ZDRC2    (OQ_ZDRC + TWOB)

# define OQ_TX       17
# define OQ_TX2      (OQ_TX + TWOB)

# define OQ_DBZX     18
# define OQ_DBZX2    (OQ_DBZX + TWOB)

# define OQ_SNR      19
# define OQ_SNR2     (OQ_SNR + TWOB)

# define OQ_TV       20
# define OQ_TV2      (OQ_TV + TWOB)

# define OQ_DBZV     21
# define OQ_DBZV2    (OQ_DBZV + TWOB)

# define OQ_PMI      22
# define OQ_PMI2     (OQ_PMI + TWOB)

# define OQ_LOG      23
# define OQ_LOG2     (OQ_LOG + TWOB)

# define OQ_CSP      24
# define OQ_CSP2     (OQ_CSP + TWOB)

# define OQ_CCOR     25
# define OQ_CCOR2    (OQ_CCOR + TWOB)

# define OQ_PIA      26 /* Ah in IRIS */
# define OQ_PIA2     (OQ_PIA + TWOB)

# define OQ_ATTV     27 
# define OQ_ATTV2    (OQ_ATTV + TWOB)

# define OQ_ATTZDR   28
# define OQ_ATTZDR2  (OQ_ATTZDR + TWOB)

# define OQ_VRADV    29
# define OQ_VRADV2   (OQ_VRADV + TWOB)

# define OQ_WRADV    30
# define OQ_WRADV2   (OQ_WRADV + TWOB)

# define OQ_SQIV     31
# define OQ_SQIV2    (OQ_SQIV + TWOB)


/*!\struct QuantCfg
\brief Quantity \#M attributes of dataset (scan) \#N (ODIM HDF5 <B>/datasetN/dataM/what</B> group).
This is used only when encoding.
*/

typedef struct {
                 char quantity[20]; /*!< Output quantity name (ODIM convention) */
                 char in_quantity[20]; /**< Input quantity name (IRIS convention) */
                 double gain; /**< gain to calculate physical quantity from binary. 
( phys_q = gain * bin_q +  offset )
*/
                 double offset; /**< offset to calculate physical quantity from binary */
                 int nodata; /**< value used for area not scanned */
                 int undetect; /**< value used for measurement under detection limit, e.g. no echo detected */
               } QuantCfg;

/*!\struct RootWhat
\brief HDF5 group <B>/what</B> attributes
*/
typedef struct {
                  char object[20];
                  char version[20]; /* V23 e.g. H5rad 2.3 */
                  char date[10];
                  char time[10];
                  char source[200];
               } RootWhat;

/*!\struct RootWhere
\brief HDF5 group <B>/where</B> attributes
*/
typedef struct {
                  char sitecode[4]; /* external, IRIS site */
                  double lat;
                  double lon;
                  double height;
                  double towerheight; /* FMI IRIS specific addition */
               } RootWhere;

/*!\struct How
\brief HDF5 group <B>/how</B> attributes both for /how and /datasetN/how
*/
typedef struct {
                  int64_t scan_count; /* V23 */
                  double beamwidth;
                  double beamwH; /* V23 */
                  double beamwV; /* V23 */
                  double wavelength;
                  double RXloss;
                  double RXlossH; /* V23 */
                  double RXlossV; /* V23 */
                  double CWloss; /* V23 IRIS specific 1.4 dB, correction to continuous calib signal vs pulsed */
                  double antgain;
                  double antgainH; /* V23 */
                  double antgainV; /* V23 */
                  double peakpwr;
                  double radomeloss;
                  double gasattn;
                  double nomTXpower;
                  double TXpower;
                  double TXloss;
                  double TXlossH; /* V23 */
                  double TXlossV; /* V23 */
                  double radomelossH; /* V23 */ 
                  double radomelossV; /* V23 */ 
                  double powerdiff; /* V23 */
                  double phasediff; /* V23 */
                  char system[100];
                  char TXtype[100]; /* V23 */
                  char poltype[100]; /* V23 */
                  char polmode[100]; /* V23 */
                  char software[100]; /* V23 */
                  char sw_version[200];
                  char comment[500];
                  double dynrange;
                  double RAC; /* range attenuation correction dB/km */
                  double pointaccEL; /* V23 [deg] */
                  double pointaccAZ; /* V23 */
                  char anglesync[100]; /* V23 azimuth|elevation */
                  double anglesyncRes; /* V23 [deg] */
                  double OUR; /* V23 [%] */
                  double freeze; /* [km] */
                  double melting_layer_top; /* V23 */
                  double melting_layer_bottom; /* V23 */

                  int64_t scan_index; /* V23 */
                  char task[50];
                  char data_origin[500]; /* V23 CSV list of possible data modification processes, e.g. AnDRe */ 
                  double startepochs; /* V23 UNIX seconds of scan start */
                  double endepochs; /* V23 UNIX seconds of scan end */
                  double radhoriz;
                  double MDSH;
                  double MDSV;
                  double SQI;
                  double CSR;
                  double LOG;
                  double S2N;
                  double PMI;
                  double rpm;
                  double antspeed; /* V23 [deg/s] */
                  double angres; /* Angular ray resolution of the scan, IRIS internal */
                  double pulsewidth;
                  double lowprf;
                  double highprf;
                  double avgpwr;
                  short POL_H;  /* IRIS specific flag */
                  short POL_V;  /* IRIS specific flag */
                  short POL_HV; /* IRIS specific flag */
                  char polarization[4]; /* H,V (H+V simultaneous)  */
                  int64_t Vsamples;
                  double UnambVel; /* IRIS specific, for VVP-unaliased also */
                  double NI; /* Nyqvist interval */
                  double NyqWidth; /* IRIS specific, NI for WRAD */
                  double radconstH; /* V23 */
                  double radconstV; /* V23 */
                  double radconstHV; /* IRIS specific */
                  double RXbandwidth; /* V23 MHz */
                  double NEZ; /* Noise Equivalent reflectivity [dBZ], see MDS */
                  double NEZH; /* V23 */
                  double NEZV; /* V23 */
                  double HVratio; /* IRIS internal */
                  char azmethod[100]; /* V23 azimuth data acquisition method NEAREST | AVERAGE (if 2PRF in IRIS)  */
                  char elmethod[100]; /* V23 elevation data acquisition method NEAREST | AVERAGE */
                  char binmethod[100]; /* V23 bin data acquisition method NEAREST | AVERAGE */
                  int64_t binmethod_avg; /* V23 averaged bins if method AVERAGE */
                  char ProcMode[16];
                  char XMTphase[16];
                  uint16_t Cflags[2];
                  double LDR_bias;
                  double ZDR_bias;
                  double startazA[MAX_AZIMS]; /* V23: list of scan start azimuths per ray */ 
                  double stopazA[MAX_AZIMS];  /* V23: list of scan stop azimuths per ray */ 
                  double startelA[MAX_AZIMS]; /* V23: list of scan start elevations per ray */ 
                  double stopelA[MAX_AZIMS];  /* V23: list of scan stop elevations per ray */ 
                  double startT[MAX_AZIMS];   /* V23: list of start times per ray */ 
                  double stopT[MAX_AZIMS];    /* V23: list of stop times per ray */ 
                  char malfunc[6]; /* V23 */
                  char radar_msg[500]; /* V23 */
                  char Dclutter[200];                
                  char clutterType[500]; /* V23 */
                  char clutterMap[256]; /* V23 */
                  double zcalH; /* V23 */
                  double zcalV; /* V23 */
                  double zdrcal; /* V23 */
                  double nsampleH; /* V23 */
                  double nsampleV; /* V23 */
                  char VPRCorr[6]; /* V23 True|False */
                  double SNRT;   /* V23 */
                  double SNRHCT; /* V23 */
                  double SNRHXT; /* V23 */
                  double SNRVCT; /* V23 */
                  double SNRVXT; /* V23 */
                  char smoothed_PHIDP[6]; /* V23 True|False */
               } How;

/*!\struct DataWhat
\brief Specific information of a quantity. Used only to relay quantity reference between decoder and encoder.   
*/
typedef struct {
                  short bytes; /*!< Quantity resolution: bytes per range gate (from IRIS) */
                  short QuantIdx; /*!< Code of a quantity, see defined OQ codes */
                  char  quantity[20]; /*!< Quantity name (ODIM). Quantity attributes 
for encoding are searched from QuantCfg using this */
               } DataWhat; 

/*!\struct DataHow
\brief Dataset \#N data \#M specific HDF5 group <B>/datasetN/dataM/how</B> attributes 
*/
typedef struct {
                  double SQI;
                  double CSR;
                  double LOG;
                  double S2N;
                  double PMI; /* IRIS specific (Polarimetric Meteo Index) */
                  double SNRT;   /* V23 same as S2N */
                  double SNRHCT; /* V23 */
                  double SNRHXT; /* V23 */
                  double SNRVCT; /* V23 */
                  double SNRVXT; /* V23 */
               } DataHow;

/*!\struct SetWhat
\brief Dataset \#N specific HDF5 group <B>/datasetN/what</B> attributes 
*/
typedef struct {
                  char startdate[10];
                  char enddate[10];
                  char starttime[10];
                  char endtime[10];
               } SetWhat; 

/*!\struct SetWhere
\brief Dataset \#N specific HDF5 group <B>/datasetN/where</B> attributes 
*/
typedef struct {
                  int64_t bin_elangle; /* IRIS specific */
                  double elangle;
                  double rstart;
                  double rscale;
                  int64_t nbins;
                  int64_t nrays;
                  int64_t a1gate;
                  double startaz; /* V23 sector specific */
                  double stopaz;  /* V23 sector specific */
                  double startel; /* V23 sector specific */
                  double stopel;  /* V23 sector specific */
               } SetWhere; 

/*!\struct QuantitySet
\brief Quantity specific attributes 
*/
typedef struct {
                  DataWhat what;
                  DataHow how;
               } QuantitySet;

/*!\struct DataSet
\brief Dataset specific attributes (common attributes of a scan) 
*/
typedef struct {
                  short quantities; /* external: amount of quantities */ 
                  QuantitySet data[MAX_QUANTS]; 
                  SetWhat what;
                  SetWhere where;
                  How how;
               } DataSet;

/*!\struct MetaData
\brief <B><I>Whole meta data structure, an envelope for other structures 
*/
typedef struct {
                  int64_t scans; /* external: scan count from IRIS.
				   OBSOLETE, see /how/scan_count */
                  RootWhat what;
                  RootWhere where;
                  How how;
                  DataSet dataset[MAX_SCANS]; /* scans */
               } MetaData;

